#!/usr/bin/env bash
# yoink - pull files from remote machines via nav-engine

set -euo pipefail

COPY_MODE=false
SKIP_CONFIRM=false
NAV_FLAGS=""

POSITIONAL=()
for arg in "$@"; do
    case "$arg" in
        -c|--copy) COPY_MODE=true ;;
        -l|--luck) SKIP_CONFIRM=true ;;
        --log) NAV_FLAGS="--log" ;;
        -*|yeet) ;;
        *) POSITIONAL+=("$arg") ;;
    esac
done
set -- "${POSITIONAL[@]}"

if [[ $# -lt 3 ]]; then
    echo "Usage: yoink [-c] <items...> <host> <path>"
    echo ""
    echo "Examples:"
    echo "  yoink file.txt nuremberg ~           # pull file from home"
    echo "  yoink *.log backup.db vps d          # pull multiple from Downloads"
    echo "  yoink -c data.sql server w/backups   # copy (keep remote)"
    echo ""
    echo "Options:"
    echo "  -c, --copy    Keep source on remote (default: move)"
    echo "  -l, --luck    Skip confirmation prompt"
    echo "  --log         Show nav-engine resolution debug info"
    echo ""
    echo "Always pulls to current directory."
    echo "Resolves remote path via nav-engine."
    exit 1
fi

# Last arg is remote path, second-to-last is host, rest are items
args=("$@")
REMOTE_PATH_QUERY="${args[-1]}"
HOST="${args[-2]}"
ITEMS=("${args[@]:0:$#-2}")

# If shell expanded ~ to local $HOME, convert back to ~ for remote
[[ "$REMOTE_PATH_QUERY" == "$HOME" || "$REMOTE_PATH_QUERY" == "$HOME/"* ]] && REMOTE_PATH_QUERY="~${REMOTE_PATH_QUERY#$HOME}"

# Resolve remote base path via SSH (bootstrap nav-engine)
REMOTE_PATH=$(cat "$LIBDIR/nav-engine.sh" | ssh "$HOST" "TERM=dumb bash -s -- '$REMOTE_PATH_QUERY'" 2>/dev/null) || {
    echo "yoink: failed to resolve '$REMOTE_PATH_QUERY' on $HOST" >&2
    exit 1
}

if [[ "$SKIP_CONFIRM" == false ]]; then
    # Check which files exist on remote
    FOUND_ITEMS=()
    MISSING_ITEMS=()
    for item in "${ITEMS[@]}"; do
        if ssh "$HOST" "test -e '$REMOTE_PATH/$item'" 2>/dev/null; then
            FOUND_ITEMS+=("$item")
        else
            MISSING_ITEMS+=("$item")
        fi
    done

    if [[ ${#FOUND_ITEMS[@]} -eq 0 ]]; then
        echo "yoink: no matching files found on $HOST:$REMOTE_PATH" >&2
        exit 1
    fi

    echo "Yoinking:"
    for item in "${FOUND_ITEMS[@]}"; do
        echo -e "  - \033[34m$item\033[0m"
    done
    for item in "${MISSING_ITEMS[@]}"; do
        echo -e "  - \033[9;31m$item\033[0m"
    done
    echo "From:"
    echo -e "  \033[1;36m$HOST:$REMOTE_PATH\033[0m"
    echo
    read -p "Y/n: " confirm

    if [[ "$confirm" =~ ^[Nn] ]]; then
        echo "Cancelled"
        exit 0
    fi

    # Clear confirmation output (Yoinking: + items + From: + path + empty + Y/n)
    printf "\033[%dA\033[J" $((${#ITEMS[@]} + 5))
else
    # Skip checks, use all items
    FOUND_ITEMS=("${ITEMS[@]}")
fi

ITEM_LIST="${FOUND_ITEMS[*]}"

# Transfer
RSYNC_PID=""
SUCCESS=false

cleanup() {
    if [[ -n "${RSYNC_PID:-}" ]] && kill -0 "$RSYNC_PID" 2>/dev/null; then
        kill "$RSYNC_PID" 2>/dev/null
        wait "$RSYNC_PID" 2>/dev/null
    fi
}

trap cleanup INT TERM EXIT

RSYNC_FLAGS="-az"
[[ "$COPY_MODE" == false ]] && RSYNC_FLAGS="-az --remove-source-files"

# Build rsync sources (only found items)
RSYNC_SOURCES=()
for item in "${FOUND_ITEMS[@]}"; do
    RSYNC_SOURCES+=("$HOST:$REMOTE_PATH/$item")
done

printf "Yoinking"

rsync $RSYNC_FLAGS "${RSYNC_SOURCES[@]}" . 2>/dev/null &
RSYNC_PID=$!

DOTS=""
while kill -0 "$RSYNC_PID" 2>/dev/null; do
    printf "\rYoinking%-3s" "$DOTS"
    DOTS="${DOTS}."
    [[ ${#DOTS} -gt 3 ]] && DOTS=""
    sleep 0.3
done
wait "$RSYNC_PID"
RSYNC_EXIT=$?

if [[ $RSYNC_EXIT -ne 0 ]]; then
    printf "\rYoink failed\n"
    exit 1
fi

SUCCESS=true

# Clean final output
printf "\r\033[K"
printf "Yoinked \033[34m%s\033[0m\n" "$ITEM_LIST"
printf " \033[1;36m‚Üê %s:%s\033[0m\n" "$HOST" "$REMOTE_PATH"
